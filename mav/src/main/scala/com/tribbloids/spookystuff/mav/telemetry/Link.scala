package com.tribbloids.spookystuff.mav.telemetry

import com.tribbloids.spookystuff.session.python.{CaseInstanceRef, PythonDriver}
import com.tribbloids.spookystuff.session.{AutoCleanable, Lifespan}
import com.tribbloids.spookystuff.{SpookyContext, caching}

import scala.collection.Map

object Link {

  // max 1 per task/thread.
  val driverLocal: caching.ConcurrentMap[PythonDriver, Link] = caching.ConcurrentMap()

  // connStr -> (link, isBusy)
  // only 1 allowed per connStr, how to enforce?
  val existing: caching.ConcurrentMap[String, (ProxyFactory, Link)] = caching.ConcurrentMap()

  // won't be used to create any link before its status being recovered by ping daemon.
  val unreachable: caching.ConcurrentSet[String] = caching.ConcurrentSet()

  //in the air but unused
  def idle: Map[String, (ProxyFactory, Link)] = existing.filter {
    tuple =>
      !unreachable.contains(tuple._1) &&
        !tuple._2._2.isBusy
  }

  /**
    * create a telemetry link based on the following order:
    * if one is already created in the same task, reuse it
    * if one is created in a previous task and not busy, use it. The busy status is controlled by whether it has an active python driver.
    *   - if its generated by an obsolete ProxyFactory, terminate the link and immediately recreate a new one with the new ProxyFactory,
    *     being created means the drone is already in the air, and can be deployed much faster
    * * if multiple are created by previous tasks and not busy, use the one that is closest to the first waypoint * (not implemented yet)
    * If none of the above exists, create one from candidates from scratch
    * remember: once the link is created its proxy is bind to it until death.
    */
  def getOrCreate(
                   candidates: Seq[Endpoint],
                   proxyFactory: ProxyFactory,
                   driver: PythonDriver
                 ): Link = {

    driverLocal
      .get(driver)
      .orElse {
        getOrRefitIdle(candidates, proxyFactory)
      }
      .getOrElse {
        val neo = create(candidates, proxyFactory)
        neo
      }
  }

  // CAUTION: this will recreate the telemetry link if ProxyFactory is different.
  def getOrRefitIdle(candidates: Seq[Endpoint], proxyFactory: ProxyFactory): Option[Link] = {
    val idleEndpointOpt = candidates.find {
      endpoint =>
        idle.get(endpoint.connStr).nonEmpty
    }
    val idleOpt = idleEndpointOpt.flatMap {
      endpoint =>
        idle.get(endpoint.connStr)
    }

    idleOpt.map {
      tuple =>
        if (tuple._1 != proxyFactory) {
          //recreate
          tuple._2.clean()
          val endpoint = idleEndpointOpt.get
          val result = apply(endpoint, proxyFactory)
          result
        }
        else {
          tuple._2
        }
    }
  }

  def create(candidates: Seq[Endpoint], proxyFactory: ProxyFactory): Link = {
    val endpoint = candidates.find {
      v =>
        !existing.contains(v.connStr) &&
          !unreachable.contains(v.connStr)
    }
      .getOrElse(
        throw new UnsupportedOperationException("reinforcement depleted :-<")
      )

    apply(endpoint, proxyFactory)
  }

  def apply(
             endpoint: Endpoint,
             proxyFactory: ProxyFactory
           ): Link = {

    val result = Link(
      endpoint,
      proxyFactory.apply(endpoint)
    )
    //    driverLocals.put(taskThreadInfo, result)
    existing.put(result.endpoint.connStr, proxyFactory -> result)
    result
  }
}

/**
to keep a drone in the air, a python daemon process D has to be constantly running to
supervise task-irrelevant path planning (e.g. RTL/Position Hold/Avoidance).
This process outlives each task. Who launches D? how to ensure smooth transitioning
of control during Partition1 => D => Partition2 ? Can they share the same
Connection / Endpoint / Proxy ? Do you have to make them picklable ?

GCS:UDP:xxx ------------------------> Proxy:TCP:xxx -> Drone
                                   /
TaskProcess -> Connection:UDP:xx -/
            /
DaemonProcess   (can this be delayed to be implemented later? completely surrender control to GCS after Altitude Hold)
  is Vehicle picklable? if yes then that changes a lot of things.
  but if not ...
    how to ensure that an interpreter can takeover and get the same vehicle?
  */
case class Link private(
                         endpoint: Endpoint,
                         proxy: Option[Proxy],
                         var proxyPID: Option[Int] = None //if set a value no proxy will be launched.
                       ) extends CaseInstanceRef with AutoCleanable {

  //cleanup by shutdown hook
  override def lifespan: Lifespan = Lifespan.JVM()

  //the first pid created in python is persisted
  //Automatically set its status in existing to 'NOT busy' at the end of this task.
  override def _Py(driver: PythonDriver, spookyOpt: Option[SpookyContext]): PyBinding = this.synchronized{
    assert(this.driverToBindings.keys.forall(_ == driver), "One link cannot be binded to 2 Python process due to port conflict")
    val result = super._Py(driver, spookyOpt)
    Link.driverLocal.put(driver, this)
    val pidOpt = result.proxyPID.strOpt.map(_.toInt)
    this.proxyPID = pidOpt
    result
  }

  override def _cleanImpl(): Unit = {

    this.scratch {
      py =>
        py.terminate()
    }
    super._cleanImpl()
  }

  // return true if its binding's python driver is not dead
  def isBusy: Boolean = {
    this.bindings.nonEmpty
  }
}