package com.tribbloids.spookystuff.mav.telemetry

import com.tribbloids.spookystuff.{SpookyContext, caching}
import com.tribbloids.spookystuff.mav.{MAVConf, ReinforcementDepletedException}
import com.tribbloids.spookystuff.session.python._
import com.tribbloids.spookystuff.session.{LocalCleanable, Session}
import com.tribbloids.spookystuff.utils.SpookyUtils
import org.slf4j.LoggerFactory

case class Endpoint(
                     // remember, one drone can have several telemetry
                     // endpoints: 1 primary and several backups (e.g. text message-based)
                     // TODO: implement telemetry backup mechanism, can use MAVproxy's multiple master feature
                     connStrs: Seq[String],
                     vehicleTypeOpt: Option[String] = None
                   ) extends CaseInstanceRef {

  def connStr = connStrs.head
}

object Link extends StaticRef {

  // max 1 per task/thread.
  val driverLocal: caching.ConcurrentMap[PythonDriver, Link] = caching.ConcurrentMap()

  // connStr -> (link, isBusy)
  // only 1 allowed per connStr, how to enforce?
  // TODO: change to Endpoint -> tuple mapping?
  val existing: caching.ConcurrentMap[String, Link] = caching.ConcurrentMap()

  // won't be used to create any link before its status being recovered by ping daemon.
  val blacklist: caching.ConcurrentSet[String] = caching.ConcurrentSet()

  //in the air but unused
  //  def idle: Map[String, (ProxyFactory, Link)] = existing.filter {
  //    tuple =>
  //      !blacklist.contains(tuple._1) &&
  //        !tuple._2._2.isBusy
  //  }

  def getOrInitialize(
                       candidates: Seq[Endpoint],
                       proxyFactory: ProxyFactory,
                       session: Session
                     ): Link = {
    session.initializeDriverIfMissing {
      getOrCreate(candidates, proxyFactory, session)
    }
  }

  /**
    * create a telemetry link based on the following order:
    * if one is already created in the same task, reuse it
    * if one is created in a previous task and not busy, use it. The busy status is controlled by whether it has an active python driver.
    *   - if its generated by an obsolete ProxyFactory, terminate the link and immediately recreate a new one with the new ProxyFactory,
    *     being created means the drone is already in the air, and can be deployed much faster
    * * if multiple are created by previous tasks and not busy, use the one that is closest to the first waypoint * (not implemented yet)
    * If none of the above exists, create one from candidates from scratch
    * remember: once the link is created its proxy is bind to it until death.
    */
  def getOrCreate(
                   candidates: Seq[Endpoint],
                   proxyFactory: ProxyFactory,
                   session: Session
                 ): Link = this.synchronized {

    val local = driverLocal
      .get(session.pythonDriver)

    local.foreach {
      link =>
        LoggerFactory.getLogger(this.getClass).info(
          ""
        )
    }

    val result = local
      .orElse {
        refitIdle(candidates, proxyFactory, session)
      }
      .getOrElse {
        elect(candidates, proxyFactory, session)
      }
    result
  }

  // CAUTION: this will refit the telemetry link with new Proxy and clean the old one if ProxyFactory is different.
  def refitIdle(
                 candidates: Seq[Endpoint],
                 proxyFactory: ProxyFactory,
                 session: Session
               ): Option[Link] = this.synchronized {

    val existingCandidates: Seq[Link] = candidates.collect {
      Function.unlift {
        endpoint =>
          existing.get(endpoint.connStr)
      }
    }

    val idleLinkOpt = existingCandidates.find {
      link =>
        link.isFinished
    }

    val result = idleLinkOpt match {
      case Some(idleLink) =>
        val newLink = if (!proxyFactory.canCreate(idleLink)) {
          idleLink.tryClean()
          // recreate proxy
          val newProxyOpt = proxyFactory.apply(idleLink.endpoint)
          idleLink.copy(proxyOpt = newProxyOpt)(session.spooky)
        }
        else {
          idleLink
        }
        LoggerFactory.getLogger(this.getClass).info {
          s"Refitting telemetry Link for ${newLink.endpoint.connStr}"
        }
        Some(newLink)
      case None =>
        LoggerFactory.getLogger(this.getClass).info{
          if (existingCandidates.isEmpty) {
            s"No existing telemetry Link for ${candidates.map(_.connStr).mkString("[", ", ", "]")}"
          }
          else {
            existingCandidates.map {
              link =>
                assert(!link.isFinished)
                s"${link.endpoint.connStr} is busy"
            }
              .mkString("\n")
          }
        }
        None
    }
    result.foreach(_.Py(session))
    result
  }

  def elect(
             candidates: Seq[Endpoint],
             proxyFactory: ProxyFactory,
             session: Session
           ): Link = this.synchronized {
    val endpoint = candidates.find {
      v =>
        !existing.contains(v.connStr) &&
          !blacklist.contains(v.connStr)
    }
      .getOrElse(
        throw new ReinforcementDepletedException (
          candidates.map {
            candidate =>
              if (blacklist.contains(candidate.connStr)) s"\t${candidate.connStr} is unreachable"
              else s"\t${candidate.connStr} is busy"
          }
            .mkString("\n")
        )
      )

    create(endpoint, proxyFactory, session)
  }

  def create(
              endpoint: Endpoint,
              proxyFactory: ProxyFactory,
              session: Session
            ): Link = {

    val result = Link(
      endpoint,
      proxyFactory.apply(endpoint)
    )(
      session.spooky
    )
    //    driverLocals.put(taskThreadInfo, result)
    result.Py(session)
    result
  }
}

//TODO: move to PyRef
//trait PreBindedRef extends PyRef {
//
//  def driver: PythonDriver
//  def spookyOpt: Option[SpookyContext]
//
//  val PY = _Py(driver, spookyOpt)
//
//  // Keep synchronization as it can only be legally called once
//  override def _Py(driver: PythonDriver, spookyOpt: Option[SpookyContext]): PyBinding = this.synchronized {
//    assert(
//      driver == this.driver,
//      "Another Python process is still alive, close that first to avoid port conflict"
//    )
//    super._Py(driver, spookyOpt)
//  }
//}

/**
to keep a drone in the air, a python daemon process D has to be constantly running to
supervise task-irrelevant path planning (e.g. RTL/Position Hold/Avoidance).
This process outlives each task. Who launches D? how to ensure smooth transitioning
of control during Partition1 => D => Partition2 ? Can they share the same
Connection / Endpoint / Proxy ? Do you have to make them picklable ?

GCS:UDP:xxx ------------------------> Proxy:TCP:xxx -> Drone
                                   /
TaskProcess -> Connection:UDP:xx -/
            /
DaemonProcess   (can this be delayed to be implemented later? completely surrender control to GCS after Altitude Hold)
  is Vehicle picklable? if yes then that changes a lot of things.
  but if not ...
    how to ensure that an interpreter can takeover and get the same vehicle?
  */
case class Link private[telemetry](
                                    endpoint: Endpoint,
                                    proxyOpt: Option[Proxy]
                                  )(
                                    val spooky: SpookyContext
                                  ) extends CaseInstanceRef with LocalCleanable {

  {
    val unfinished = Link.existing.values.filterNot(_.isFinished)
    assert(!unfinished.map(_.endpoint.connStr).toSet.contains(this.endpoint.connStr),
      s"endpoint ${this.endpoint.connStr} is already used")

    this.proxyOpt.foreach {
      proxy =>
        assert(!unfinished.flatMap(_.proxyOpt).map(_.primaryOut).toSet.contains(proxy.primaryOut),
          s"proxy ${proxy.primaryOut} is already used")
    }
    Link.existing.put(endpoint.connStr, this)
    spooky.metrics.linkCreated += 1
  }

  override def _Py(driver: PythonDriver, spookyOpt: Option[SpookyContext]): LinkPyBinding = {
    driverToBindings.get(driver)
      .map(_.asInstanceOf[LinkPyBinding])
      .getOrElse(
        new LinkPyBinding(this, driver, spookyOpt)
      )
  }

  override def cleanImpl(): Unit = {

    proxyOpt.foreach(_.tryClean())
    super.cleanImpl()
    Link.existing -= this.endpoint.connStr

    spooky.metrics.linkDestroyed += 1
  }

  def isFinished: Boolean = {
    driverToBindings.isEmpty
  }
}

class LinkPyBinding(
                     override val ref: Link,
                     override val driver: PythonDriver,
                     override val spookyOpt: Option[SpookyContext]
                   ) extends PyBinding(ref, driver, spookyOpt) {

  assert(Link.driverToBindings.keys.forall(_.isCleaned), "Link can only be bind to one driver")

  Helpers.autoStart()
  Link.driverLocal += driver -> ref

  private object Helpers {
    // will retry 6 times, try twice for Vehicle.connect() in python, if failed, will restart proxy and try again (3 times).
    // after all attempts failed will add endpoint into blacklist and destroy proxy
    def autoStart(): String = {

      try {
        var needRestart = false
        val retries = spookyOpt.map(
          spooky =>
            spooky.conf.submodules.get[MAVConf]().connectionRetries
        ).getOrElse(1)
        SpookyUtils.retry(retries) {
          needRestart = true
          ref.proxyOpt.foreach {
            proxy =>
              if (needRestart) {
                proxy.managerPy.restart()
              }
              else {
                proxy.managerPy.start()
              }
          }
          val result = LinkPyBinding.this.start().strOpt.get
          result
        }
      }
      catch {
        case e: Throwable =>
          ref.proxyOpt.foreach {
            proxy =>
              proxy.managerPy.stop()
          }

          LoggerFactory.getLogger(this.getClass).error(
            s"${ref.endpoint.connStr} is unreachable, adding to blacklist"
          )
          //TODO: enable after ping daemon is implemented
          //            Link.blacklist += endpoint.connStr
          throw e
      }
    }
  }

  override def cleanImpl(): Unit = {

    super.cleanImpl()
    Link.driverLocal -= driver
  }
}